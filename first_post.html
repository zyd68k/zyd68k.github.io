<!doctype html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>zyd68k's site</title>
    <link href="style.css" rel="stylesheet" />
  </head>
  <body>
	  <h1>post title</h1>
	  <p>
	     <a href="https://youtu.be/dQw4w9WgXcQ?si=_gxCsEObWOzgNy55">lol</a> </br>
	  </p>
	  <p>
	  <pre>
	     .text:00401236
             .text:00401236 ; =============== S U B R O U T I N E =======================================
             .text:00401236
             .text:00401236 ; Attributes: bp-based frame
             .text:00401236
             .text:00401236 ; void __cdecl sub_401236()
             .text:00401236 sub_401236      proc near               ; DATA XREF: start+DB↑o
             .text:00401236
             .text:00401236 var_1C          = dword ptr -1Ch
             .text:00401236 ms_exc          = CPPEH_RECORD ptr -18h
             .text:00401236
             .text:00401236 ; __unwind { // __SEH_prolog
             .text:00401236                 push    0Ch
             .text:00401238                 push    offset stru_402078
             .text:0040123D                 call    __SEH_prolog
             .text:00401242                 mov     [ebp+var_1C], offset unk_4020E0
             .text:00401249
             .text:00401249 loc_401249:                             ; CODE XREF: sub_401236+3C↓j
             .text:00401249                 cmp     [ebp+var_1C], offset unk_4020E0
             .text:00401250                 jnb     short loc_401274
             .text:00401252 ;   __try { // __except at loc_401267
             .text:00401252                 and     [ebp+ms_exc.registration.TryLevel], 0
             .text:00401256                 mov     eax, [ebp+var_1C]
             .text:00401259                 mov     eax, [eax]
             .text:0040125B                 test    eax, eax
             .text:0040125D                 jz      short loc_40126A
             .text:0040125F                 call    eax
             .text:00401261                 jmp     short loc_40126A
             .text:00401263 ; ---------------------------------------------------------------------------
             .text:00401263
             .text:00401263 loc_401263:                             ; DATA XREF: .rdata:stru_402078↓o
             .text:00401263 ;   __except filter // owned by 401252
             .text:00401263                 xor     eax, eax
             .text:00401265                 inc     eax
             .text:00401266                 retn
	  </pre>
	  </p>
	  <p>
	  <pre>
             bool CIRCSock::OnCTCPMessage(CCTCPMessage& Message) {
                 bool bResult = false;
                 CChan* pChan = nullptr;
                 CString sTarget = Message.GetTarget();
                 if (sTarget.Equals(GetNick())) {
                     if (Message.IsReply()) {
                         IRCSOCKMODULECALL(OnCTCPReplyMessage(Message), &bResult);
                         return bResult;
                     } else {
                         IRCSOCKMODULECALL(OnPrivCTCPMessage(Message), &bResult);
                         if (bResult) return true;
                     }
                 } else {
                     pChan = m_pNetwork->FindChan(sTarget);
                     if (pChan) {
                         Message.SetChan(pChan);
                         FixupChanNick(Message.GetNick(), pChan);
                         if (Message.IsReply()) {
                             IRCSOCKMODULECALL(OnCTCPReplyMessage(Message), &bResult);
                             return bResult;
                         } else {
                             IRCSOCKMODULECALL(OnChanCTCPMessage(Message), &bResult);
                         }
                         if (bResult) return true;
                     }
                 }
             
                 const CNick& Nick = Message.GetNick();
                 const CString& sMessage = Message.GetText();
                 const MCString& mssCTCPReplies = m_pNetwork->GetUser()->GetCTCPReplies();
                 CString sQuery = sMessage.Token(0).AsUpper();
                 MCString::const_iterator it = mssCTCPReplies.find(sQuery);
                 bool bHaveReply = false;
                 CString sReply;
             
                 if (it != mssCTCPReplies.end()) {
                     sReply = m_pNetwork->ExpandString(it->second);
                     bHaveReply = true;
             
                     if (sReply.empty()) {
                         return true;
                     }
                 }
             
                 if (!bHaveReply && !m_pNetwork->IsUserAttached()) {
                     if (sQuery == "VERSION") {
                         sReply = CZNC::GetTag(false);
                     } else if (sQuery == "PING") {
                         sReply = sMessage.Token(1, true);
                     }
                 }
             
                 if (!sReply.empty()) {
                     unsigned long long now = CUtils::GetMillTime();
                     // If the last CTCP is older than m_uCTCPFloodTime, reset the counter
                     if (m_lastCTCP + m_uCTCPFloodTime < now) m_uNumCTCP = 0;
                     m_lastCTCP = now;
                     // If we are over the limit, don't reply to this CTCP
                     if (m_uNumCTCP >= m_uCTCPFloodCount) {
                         DEBUG("CTCP flood detected - not replying to query");
                         return true;
                     }
                     m_uNumCTCP++;
             
                     PutIRC("NOTICE " + Nick.GetNick() + " :\001" + sQuery + " " + sReply +
                            "\001");
                     return true;
                 }
             
                 return (pChan && pChan->IsDetached());
             }
          </br>
	  </pre>
	  </p>
	  <footer>No Rights Reserved. </footer>
  </body>
</html>
